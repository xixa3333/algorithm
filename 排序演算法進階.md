# 排序演算法

## 合併排序(分治排序)

> 利用分治法把一個原序列分成多個子序列去排序。

1. 將一個序列分成左半跟右半
2. 將左與右序列重複步驟1直到無法再分一半
3. 每個序列去排序
4. 每兩兩序列合併
5. 重複步驟3-4直到變回一個序列

![image](https://github.com/xixa3333/algorithm/assets/128284090/25bc862a-835d-4a61-9f6e-f495e228314f)

## 快速排序

> 都使用分治法去排序。  
> 將序列的頭作為基準點，從兩邊開始找。從左邊往右邊找比基準點大的值，從右邊往左邊找比基準點小的值，找到後互換，直到兩邊相遇，相遇的點與基準點互換，再將基準點左與右變為兩個序列去遞迴。

1. 將序列的頭作為基準點
2. 從左邊往右邊找比基準點大的值
3. 從右邊往左邊找比基準點小的值
4. 兩邊都找到後互換
5. 重複步驟2-4直到兩邊相遇在同一個點上
6. 相遇後的點與基準點互換，如值比基準點大則與相遇的前一個點互換
7. 將基準點左與右變為兩個序列
8. 把兩個序列重複做步驟1-7直到序列剩1個元素或是兩邊的點相錯沒遇到點
9. 最後將排序好的序列合併

![image](https://github.com/xixa3333/algorithm/assets/128284090/bc3bdab1-c691-469a-9195-c4314be66219)

## 希爾排序

> 為插入排序的優化版。  
> 使用步長分成好幾個序列，再從每個序列中同個索引去排序，排序完後把步長縮小後分成更多序列去排序，直到步長為1。  
> 步長通常為陣列長度/2，使用步長分成好幾個序列後排序，排序完後步長再除以2，以此類推直到步長為1。  
> 步長使用剛剛講的方法有時不會是最快速的排序，這時就可自行找尋最佳的步長去解決排序，或者是參考更多的資源了解步長選擇方法，至於步長選擇方法在進階演算法中會講解到。

1. 步長為序列長度/2
2. 將索引從0到步長-1的元素，依次與步長相差的索引去做插入排序
3. 重複步驟1-2直到步長為1時做最後一次

![image](https://github.com/xixa3333/algorithm/assets/128284090/48898577-134e-4ea7-9e8d-c553621498c8)

## 上一章：[分治法](https://github.com/xixa3333/algorithm/blob/main/%E5%88%86%E6%B2%BB%E6%B3%95.md)
## 下一章：[動態規劃](https://github.com/xixa3333/algorithm/blob/main/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83.md)
